#git settings
git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

#git параметры установки окончания строк
git config --global core.autocrlf input
git config --global core.safecrlf true

1. Коммиты
 ----------
    1.1 Коммиты должны быть атомарными и НЕБОЛЬШИМИ, т.е. одна логическая правка - один коммит.
        Все рефакторинги, переименования и пр. параллельные усовершенствования лучше оформлять отдельным коммитом.
        Ориентироваться надо на других разработчиков, которые будут просматривать эти коммиты.

    1.2 Все форматирование кода, приведение к стандарту оформлять ОТДЕЛЬНЫМ коммитом.

    1.3 Каждую миграцию структуры БД или редактирование миграции оформлять ОТДЕЛЬНЫМ коммитом.
        Чтобы иметь возможность объединить несколько коммитов по одной миграции.

    1.4 Для Git принято соглашение в первой строке сообщения писать краткое описание,
        а ЧЕРЕЗ строку - подробное. Т.е. как почтовое сообщение - заголовок и тело.
        В заголовок комментария надо обязательно включать номер тикета и тему/компонент,
        к которому он относится.
        Например:
            ----------------------
            t565 Календарь: Ошибка при добавлении периодической операции

            После добавления операции выдаётся ошибка что незаполнена категория,
            но при этом не даёт изменить её. Была проблема в формировании ответа
            json на сервере.
            ----------------------

    1.5 Для подготовки коммита НАДО использовать:
            git add -p
        Чтобы контролировать каждую правку, которая попадет в коммит.

    1.6 Перед кажым коммитом смотреть дифф будущего коммита:
            git diff --cached


 2. Ветки
 --------
    2.1 Под каждую задачу создается отдельная ветка и туда отправляются все коммиты по задаче.

    2.2 В названии ветки указывать тикет и 1-2 слова-описания: t69-profile-email

    2.3 Если работа над веткой продолжается дольше чем один день. Тогда подтягиваем
        ветку каждый день перед началом работы и после окончания, чтобы не накапливать конфликты.
        Если коммитов очень много, тогда лучше регулярно мерджить правки из основной ветки.
        Но лучше до такого не доводить и дробить задачи или объединять технические коммиты.

    2.4 Чтобы опубливать ветку для ревью или демонстрации, ее надо подтянуть к родительской:

            # Убедиться, что родительская ветка в актуальном состоянии:
            git fetch
            git co master
            git merge origin/master

            # Подтянуть ветку, если отстала
            git co my-branch
            git rebase master

            # Отправить в remote
            git push origin my-branch

    2.5 Перед тем как опубликовать ветку - посмореть полный диф всех правок:
            git diff НАЧАЛЬНЫЙ_КОММИТ..НАЗВАНИЕ_ВЕТКИ
            

            
            
            
            
            
            
            
#Создать новый репозиторий:
git init project-name

#Добавить файл в репозиторий:
git add text.txt

#Удалить добавленный файл из репозитория
git reset

#Удалить файл:
git rm text.txt

#Текущее состояние репозитория (изменения, неразрешенные конфликты и тп):
git status

#Сделать коммит:
git commit -a -m "Commit description"

#Сделать коммит, введя его описание с помощью $EDITOR:
git commit -a

#Получение списка произведенных изменений
git log

#Получение списка произведенных изменений - однострочный формат
git log --pretty=oneline

#Получение списка произведенных изменений c разными параметрами
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short

#Расшифровка ключей
    --pretty="..." — определяет формат вывода.
    %h — укороченный хэш коммита
    %d — дополнения коммита («головы» веток или теги)
    %ad — дата коммита
    %s — комментарий
    %an — имя автора
    --graph — отображает дерево коммитов в виде ASCII-графика
    --date=short — сохраняет формат даты коротким и симпатичным

#для перехода по коммитам
git checkout <hash>
где <hash> - хеш-код требуемого коммита (достаточно 7 первых знаков)

#пример файла .gitignore:
# комментарий — эта строка игнорируется
# не обрабатывать файлы, имя которых заканчивается на .a
*.a
# НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
!lib.a
# игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
/TODO
# игнорировать все файлы в каталоге build/
build/
# игнорировать doc/notes.txt, но не doc/server/arch.txt
doc/*.txt
# игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt

#Отличие индексированных файлов и файлов рабочего каталога
git diff

#команда сравнивает индексированные изменения с последним коммитом
git diff --staged

#что войдёт в следующий коммит
git diff --cached

#переименовать файл в Git'е
git mv file_from file_to

#это эквивалентно выполнению следующих команд:

git mv README.txt README
git rm README.txt
git add README

#удалить файл из индекса
git rm --cached filename



#создание репозитория на github с локальной машины
curl -u 'USER' https://api.github.com/user/repos -d '{"name":"REPO"}'

#USER и REPO заминить на имя пользователя и название папки проекта (только, то что #большими буквами).

#После этого можно делать следующее
#Ссылка на удаленный сервер (в данном случае github), имя ссылки любое
git remote add shot_link_name "https://github.com/user/myproject.git" 
#заливаем наш проект на удаленный сервер
git push -u shot_link_name master
#синхронизируем удаленный и локальный репозитории
git fetch link_name 
#синхронизируем репозитории и сливаем с нашими изменениями
git pull link_name branch_name

#отличие pull  и fetch состоит в том, что fetch вытягивает с удаленного сервера
#те изменения которых у нас нет, а  pull делает еще и слияние(т.е. применяет изменения).

#Для проверки соответствия сокращенного имени удаленному репозиторию
git remote -v

#Добавление удаленного репозитория
git remote add shot_link_name link(url)

#Для проверки изменений на удаленном сервере
git remote show shot_link_name(origin)
